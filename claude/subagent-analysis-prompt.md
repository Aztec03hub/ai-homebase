Okay Claude, today, I need extra expert-level discernment and assistance analyzing, suggesting potential improvements, and updating our subagent system and our Orchestrated Delegation the `## ðŸš¨ CRITICAL RULE - Orchestrated Subagent Workflow (2025-11-06)` in CLAUDE.md, which is lines 907 - 1094. 
For the very beginning, we should add a critical rule (*before* the filepath requirement) that *you* (the LLM reading this rule) is the orchestrator, and all subagents must be given explicit instructions that after their work is complete to give whatever feedback and information is necessary for you (the orchestrator) to be able to efficiently delegate work, tasks, and call other subagents, that the point of the subagent system is to greatly reduce the context token load you (the orchestrator) undertake during work, but that in order to be most effective, you (the orchestrator) need to have pertinent and important information about the work a subagent performs, because subagents don't have the ability to directly know what any other subagent has done or if any other subagent has key information as a result of the work they performed, so key data and observations must pass back to you (the orchestrator) in order for the system to be effective.
For the very beginning, we should add a critical rule (after the filepath requirement) that all subagents should be explicitly instructed to use `vscode-mcp-server` tools for all operations.

It's incredibly important that you understand that each subagent is called as a "one-shot" task, meaning ALL of their contextual information from each "run" is lost at the end of that "run," but since they generate an output contract at the end of each run, we have a means/method of having the responsible subagent to read that output contract to understand the previous work performed, as well as any other important or key information the previous instance of that agent collected or generated. Since multiple instances or calls of a particular subagent can sometimes generate multiple output contracts of differing names, it's extremely important that you (the orchestrator) keep careful track of the exact names and filepaths of each output contract generated - especially when you need to instruct a fresh instance of a particular subagent type to perform work *after* an initial instance of that same particular subagent type has been called or performed work.

We should specify that you (the orchestrator) must carefully determine when calling (or delegating to) a subagent, if it's necessary to have them read any previously created output contracts. Obviously, implementation agents will be told to read the complete markdown architecture plan, but other agents may benefit from being told to read additional output contracts. For example, if you (the orchestrator) know that both the database-engineer and the types-engineer will be called, it would be very beneficial for the types-engineer to read the output contract created by the database-engineer. Then in the following phase, if you (the orchestrator) know that api-backend, svelte5-frontend, and the test-engineer will all be called, it may be beneficial for them to each read the output contracts created by the database-engineer and the types-engineer.

For phase 6, the Quality Assurance loop, the janitor and code-reviewer should always be told to review any output contracts created by previously called agents.

For phase 6, the Quality Assurance loop, we need to specify that the janitor and code-reviewer tasks must not be done in parallel, but serial, with the janitor task finishing completely *before* the code-reviewer is called. 
For phase 6, the Quality Assurance loop, we need to specify that the code-reviewer should be explicitly instructed that it may *not* give approval if `get_diagnostics_code` shows any outstanding errors or warnings. 
For phase 6, the Quality Assurance loop, we need to specify that if the code-reviewer gives a rejection, that you (the orchestrator) *at the point where you're returning to the responsible agent to fix the issues,* that you instruct that responsible agent to start by reviewing/reading their own previous output contract. Furthermore, once the responsible agent or agents have attempted their fix(es) and phase 6 (the quality assurance loop) is entered again, both the janitor and the code-reviewer should be told to review/read any output contract(s) from the previous responsible agent(s) who completed work.

For The beginning of phase 7, it should start by asking the user (me) if we should continue as normal, or if anything else should be done first - this is an important stopping point in case any errors or other issues have appeared, which you may not be aware of, and we'd want any issues handled *before* generating documentation or committing git changes.

I also need you to look at the `## ðŸ§  MEMORY ENTRY - WORKFLOW - Orchestrator Delegation Pattern - CRITICAL (2025-11-06)` in CLAUDE.md, which is lines 1785 - 1805. We must understand that the `## ðŸš¨ CRITICAL RULE - Orchestrated Subagent Workflow (2025-11-06)` is the MAIN source of truth for this, with the `## ðŸ§  MEMORY ENTRY - WORKFLOW - Orchestrator Delegation Pattern - CRITICAL (2025-11-06)` simply serving to summarize and condense that critical rule. I need you to audit `## ðŸ§  MEMORY ENTRY - WORKFLOW - Orchestrator Delegation Pattern - CRITICAL (2025-11-06)` and assess whether it successfully condenses the current Orchestrated Subagent Workflow. This is also a great opportunity to suggest any improvements we could make.

use vscode-mcp-server tools for all operations possible, especially read_file_code for reading files and apply_diff for creating new files and/or modifying/editing existing files.

I need you to propose your changes to me for review before making any changes (via apply_diff).